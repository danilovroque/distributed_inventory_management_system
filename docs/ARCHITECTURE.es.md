# üèóÔ∏è Documentaci√≥n de Arquitectura

Gu√≠a de arquitectura completa para el Sistema Distribuido de Gesti√≥n de Inventario.

[üá∫üá∏ English](ARCHITECTURE.md) | [üáßüá∑ Portugu√™s](ARCHITECTURE.pt-BR.md) | [üá™üá∏ Espa√±ol](ARCHITECTURE.es.md)

## Tabla de Contenidos

1. [Descripci√≥n General](#descripci√≥n-general)
2. [Principios de Arquitectura](#principios-de-arquitectura)
3. [Capas de Arquitectura](#capas-de-arquitectura)
4. [Patrones de Dise√±o](#patrones-de-dise√±o)
5. [Flujos de Datos](#flujos-de-datos)
6. [Consideraciones de Escalabilidad](#consideraciones-de-escalabilidad)

## Descripci√≥n General

El sistema implementa una arquitectura moderna de microservicios utilizando:

- **Clean Architecture** - Separaci√≥n de responsabilidades en 4 capas
- **Event Sourcing** - Persistencia basada en eventos como fuente de verdad
- **CQRS (Command Query Responsibility Segregation)** - Modelos de lectura y escritura separados
- **DDD (Domain-Driven Design)** - Modelado rico del dominio con agregados y eventos

### Vista de Alto Nivel

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      CAPA DE PRESENTACI√ìN                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ   REST API   ‚îÇ  ‚îÇ  Middleware  ‚îÇ  ‚îÇ   Schemas    ‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   CAPA DE APLICACI√ìN                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ   Comandos   ‚îÇ  ‚îÇ   Consultas  ‚îÇ  ‚îÇ  Servicios   ‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   LADO DE ESCRITURA    ‚îÇ   ‚îÇ      LADO DE LECTURA          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ  Event Store     ‚îÇ  ‚îÇ   ‚îÇ  ‚îÇ   Read Models        ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                                   ‚îÇ
         ‚îÇ          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫   Event Bus  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      CAPA DE DOMINIO                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ  Entidades   ‚îÇ  ‚îÇ    Eventos   ‚îÇ  ‚îÇ Objetos Valor‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Principios de Arquitectura

### 1. Clean Architecture (Arquitectura Limpia)

#### Regla de Dependencia
Las dependencias apuntan hacia el interior. Las capas externas dependen de las capas internas, nunca al rev√©s.

```
Presentaci√≥n ‚Üí Aplicaci√≥n ‚Üí Dominio
Infrastructure ‚Üí Aplicaci√≥n/Dominio
```

#### Beneficios
- ‚úÖ Independencia de frameworks
- ‚úÖ Testabilidad
- ‚úÖ Independencia de UI
- ‚úÖ Independencia de base de datos
- ‚úÖ Reglas de negocio agn√≥sticas a factores externos

### 2. SOLID Principles (Principios SOLID)

- **S - Single Responsibility**: Cada clase tiene una √∫nica raz√≥n para cambiar
- **O - Open/Closed**: Abierto para extensi√≥n, cerrado para modificaci√≥n
- **L - Liskov Substitution**: Los subtipos deben ser sustituibles por sus tipos base
- **I - Interface Segregation**: Muchas interfaces espec√≠ficas del cliente
- **D - Dependency Inversion**: Depender de abstracciones, no de concreciones

### 3. Domain-Driven Design (Dise√±o Guiado por el Dominio)

- **Agregados**: Inventory como ra√≠z de agregado
- **Entidades**: Product, Inventory con identidad
- **Objetos de Valor**: StockQuantity como inmutable
- **Eventos de Dominio**: Capturan cambios de estado
- **Repositorios**: Acceso a datos basado en colecciones

## Capas de Arquitectura

### Capa 1: Dominio (N√∫cleo)

**Ubicaci√≥n**: `src/domain/`

**Responsabilidades**:
- L√≥gica de negocio y reglas
- Entidades y objetos de valor
- Eventos de dominio
- Excepciones de dominio

**Componentes Clave**:

#### Entidades
```python
# src/domain/entities/inventory.py
@dataclass
class Inventory:
    """Agregado ra√≠z para inventario"""
    product_id: UUID
    store_id: UUID
    total_quantity: StockQuantity
    reserved_quantity: StockQuantity
    version: int = 0
    pending_events: List[DomainEvent] = field(default_factory=list)
    
    def add_stock(self, quantity: StockQuantity, reason: str) -> None:
        """Agregar stock con validaci√≥n"""
        self.total_quantity = self.total_quantity.add(quantity)
        event = StockAdded(...)
        self.pending_events.append(event)
        self.version += 1
    
    def reserve_stock(self, quantity: StockQuantity, 
                      customer_id: UUID) -> UUID:
        """Reservar stock si est√° disponible"""
        available = self.get_available_quantity()
        if available < quantity:
            raise InsufficientStockError(...)
        # ... l√≥gica
```

#### Objetos de Valor
```python
# src/domain/value_objects/stock_quantity.py
@dataclass(frozen=True)
class StockQuantity:
    """Cantidad de stock inmutable con validaci√≥n"""
    value: int
    
    def __post_init__(self):
        if self.value < 0:
            raise InvalidQuantityError(...)
    
    def add(self, other: 'StockQuantity') -> 'StockQuantity':
        return StockQuantity(self.value + other.value)
```

#### Eventos de Dominio
```python
# src/domain/events/inventory_events.py
@dataclass
class StockAdded(DomainEvent):
    """Evento cuando se agrega stock"""
    product_id: UUID
    store_id: UUID
    quantity: int
    reason: str
    timestamp: datetime
```

**Principios**:
- Sin dependencias externas
- L√≥gica de negocio pura
- Inmutabilidad donde sea posible
- Validaci√≥n rica

### Capa 2: Aplicaci√≥n

**Ubicaci√≥n**: `src/application/`

**Responsabilidades**:
- Orquestaci√≥n de casos de uso
- Handlers de comandos
- Handlers de consultas
- Coordinaci√≥n de transacciones

**Componentes Clave**:

#### Comandos (Lado de Escritura)
```python
# src/application/commands/add_stock.py
@dataclass
class AddStockCommand:
    """Comando para agregar stock"""
    product_id: UUID
    store_id: UUID
    quantity: int
    reason: str

class AddStockHandler:
    """Handler con reconstrucci√≥n de Event Sourcing"""
    
    async def handle(self, command: AddStockCommand) -> None:
        # 1. Cargar eventos del event store
        events = await self.event_store.load_events(
            command.product_id, command.store_id
        )
        
        # 2. Reconstruir agregado desde eventos
        inventory = self._rebuild_from_events(events)
        
        # 3. Ejecutar comando
        inventory.add_stock(
            StockQuantity(command.quantity),
            command.reason
        )
        
        # 4. Guardar nuevos eventos
        await self.event_store.append_events(
            command.product_id,
            command.store_id,
            inventory.pending_events,
            inventory.version - len(inventory.pending_events)
        )
        
        # 5. Publicar eventos
        for event in inventory.pending_events:
            await self.event_bus.publish(event)
```

#### Consultas (Lado de Lectura)
```python
# src/application/queries/get_stock.py
class GetStockQuery:
    """Consulta con cach√©"""
    
    async def execute(self, product_id: UUID, 
                      store_id: UUID) -> StockResponse:
        # 1. Intentar cach√© primero
        cache_key = f"stock:{product_id}:{store_id}"
        cached = await self.cache.get(cache_key)
        if cached:
            return StockResponse(**cached)
        
        # 2. Consultar modelo de lectura
        stock = await self.read_model.get_stock(
            product_id, store_id
        )
        
        # 3. Almacenar en cach√© por 30s
        if stock:
            await self.cache.set(
                cache_key, stock.dict(), ttl=30
            )
        
        return stock
```

**Principios**:
- Separaci√≥n de comandos y consultas (CQRS)
- Sin l√≥gica de negocio (solo orquestaci√≥n)
- Manejo de transacciones
- Gesti√≥n de cach√©

### Capa 3: Infraestructura

**Ubicaci√≥n**: `src/infrastructure/`

**Responsabilidades**:
- Persistencia de datos
- Mensajer√≠a externa
- Cach√©
- Resiliencia

**Componentes Clave**:

#### Event Store
```python
# src/infrastructure/persistence/event_store.py
class EventStore:
    """Store de eventos con bloqueo optimista"""
    
    async def append_events(
        self,
        product_id: UUID,
        store_id: UUID,
        events: List[DomainEvent],
        expected_version: int
    ) -> None:
        """Agregar eventos con verificaci√≥n de versi√≥n"""
        
        # 1. Adquirir bloqueo para este agregado
        async with self.locks[aggregate_key]:
            # 2. Cargar versi√≥n actual
            current_version = await self._get_current_version(...)
            
            # 3. Verificar conflicto de versi√≥n
            if current_version != expected_version:
                raise ConcurrencyError(...)
            
            # 4. Agregar eventos
            await self._append_to_file(...)
```

#### Read Model Repository
```python
# src/infrastructure/persistence/read_model_repository.py
class ReadModelRepository:
    """Proyecciones optimizadas para consultas"""
    
    def update_from_event(self, event: DomainEvent) -> None:
        """Actualizar proyecci√≥n desde evento"""
        
        if isinstance(event, StockAdded):
            # Actualizar modelo de lectura desnormalizado
            stock = self._get_or_create_stock(...)
            stock.total_quantity += event.quantity
            stock.last_updated = event.timestamp
            self._save(stock)
```

#### Cache
```python
# src/infrastructure/cache/in_memory_cache.py
class InMemoryCache:
    """Cache en memoria con TTL y evicci√≥n LRU"""
    
    async def get(self, key: str) -> Optional[Dict]:
        """Obtener de cach√© con verificaci√≥n de expiraci√≥n"""
        if key in self.cache:
            entry = self.cache[key]
            if not entry.is_expired():
                entry.access_time = time.time()
                return entry.value
            del self.cache[key]
        return None
```

#### Circuit Breaker
```python
# src/infrastructure/resilience/circuit_breaker.py
class CircuitBreaker:
    """Circuit breaker con 3 estados"""
    
    async def call(self, func, *args, **kwargs):
        """Ejecutar con protecci√≥n de circuit breaker"""
        
        if self.state == State.OPEN:
            if self._should_attempt_reset():
                self.state = State.HALF_OPEN
            else:
                raise CircuitBreakerOpenError()
        
        try:
            result = await func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise
```

**Principios**:
- Implementaciones intercambiables
- Preocupaciones t√©cnicas
- No contiene l√≥gica de negocio
- Dependencias aisladas

### Capa 4: Presentaci√≥n

**Ubicaci√≥n**: `src/presentation/`

**Responsabilidades**:
- HTTP API endpoints
- Validaci√≥n de request/response
- Manejo de errores
- Middleware

**Componentes Clave**:

#### API Endpoints
```python
# src/presentation/api/v1/endpoints/inventory.py
@router.post("/stock", status_code=status.HTTP_201_CREATED)
async def add_stock(
    request: AddStockRequest,
    service: InventoryService = Depends(get_inventory_service)
) -> StockResponse:
    """Endpoint para agregar stock"""
    
    command = AddStockCommand(
        product_id=request.product_id,
        store_id=request.store_id,
        quantity=request.quantity,
        reason=request.reason
    )
    
    await service.add_stock(command)
    
    # Consultar stock actualizado
    query = GetStockQuery(
        product_id=request.product_id,
        store_id=request.store_id
    )
    return await service.get_stock(query)
```

#### Middleware
```python
# src/presentation/middleware/logging_middleware.py
class LoggingMiddleware:
    """Middleware de logging estructurado"""
    
    async def __call__(self, request: Request, 
                       call_next) -> Response:
        request_id = str(uuid4())
        
        logger.bind(request_id=request_id)
        logger.info("request_started", 
                   method=request.method, 
                   path=request.url.path)
        
        start_time = time.time()
        response = await call_next(request)
        duration = time.time() - start_time
        
        logger.info("request_completed", 
                   status_code=response.status_code,
                   duration=duration)
        
        return response
```

**Principios**:
- Preocupaciones de transporte HTTP
- Conversi√≥n de DTOs
- Manejo de errores de usuario
- Documentaci√≥n (OpenAPI)

## Patrones de Dise√±o

### 1. Event Sourcing

**Problema**: Necesidad de auditor√≠a completa y reconstrucci√≥n de estado

**Soluci√≥n**: Almacenar eventos como fuente de verdad

```python
# Flujo:
# 1. Usuario ejecuta comando ‚Üí AddStockCommand
# 2. Cargar todos los eventos ‚Üí [StockAdded, StockReserved, ...]
# 3. Reconstruir estado ‚Üí inventory.apply(event) para cada evento
# 4. Ejecutar comando ‚Üí inventory.add_stock()
# 5. Guardar nuevos eventos ‚Üí StockAdded guardado
# 6. Estado futuro = eventos pasados + nuevos eventos
```

**Beneficios**:
- Historial completo
- Consultas temporales (time travel)
- Auditor√≠a incorporada
- Depuraci√≥n facilitada

### 2. CQRS (Command Query Responsibility Segregation)

**Problema**: Los requisitos de lectura y escritura son diferentes

**Soluci√≥n**: Modelos separados para escrituras y lecturas

```
COMANDOS (Escrituras)          CONSULTAS (Lecturas)
       ‚îÇ                              ‚îÇ
       ‚ñº                              ‚ñº
  Event Store                   Read Models
  (Normalizado)                (Desnormalizado)
       ‚îÇ                              ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Events ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Beneficios**:
- Modelos de lectura optimizados
- Escalado independiente
- Diferentes requisitos de consistencia
- Mejor rendimiento de cach√©

### 3. Repository Pattern

**Problema**: Abstracci√≥n del acceso a datos

**Soluci√≥n**: Interfaz basada en colecciones para persistencia

```python
class IEventStore(ABC):
    @abstractmethod
    async def append_events(self, events: List[DomainEvent]): ...
    
    @abstractmethod
    async def load_events(self, aggregate_id: UUID): ...
```

### 4. Unit of Work

**Problema**: Gestionar l√≠mites de transacciones

**Soluci√≥n**: Coordinar m√∫ltiples operaciones de repositorio

```python
# Impl√≠cito en handlers de comandos:
async def handle(self, command):
    # 1. Cargar
    inventory = await self.load_aggregate(...)
    
    # 2. Ejecutar
    inventory.do_something()
    
    # 3. Guardar (at√≥mico)
    await self.save_aggregate(inventory)
```

### 5. Circuit Breaker

**Problema**: Fallos en cascada en sistemas distribuidos

**Soluci√≥n**: Rastrear fallos y fallar r√°pido cuando sea necesario

**Estados**:
- **CLOSED** (Cerrado): Operaci√≥n normal, rastreando fallos
- **OPEN** (Abierto): Fallo r√°pido sin intentar
- **HALF_OPEN** (Semi-abierto): Probar si el servicio se ha recuperado

### 6. Observer Pattern (Event Bus)

**Problema**: Comunicaci√≥n d√©bilmente acoplada entre componentes

**Soluci√≥n**: Pub/sub para eventos de dominio

```python
# Publishers no saben sobre subscribers
await event_bus.publish(StockAdded(...))

# Subscribers se registran por tipo de evento
event_bus.subscribe(StockAdded, update_read_model)
event_bus.subscribe(StockAdded, invalidate_cache)
```

## Flujos de Datos

### Flujo de Comando (Escritura)

```
1. Cliente ‚Üí HTTP POST /api/v1/inventory/stock
2. API Layer ‚Üí Validar con Pydantic
3. API Layer ‚Üí Crear AddStockCommand
4. Service Layer ‚Üí Invocar AddStockHandler
5. Command Handler ‚Üí Cargar eventos desde EventStore
6. Command Handler ‚Üí Reconstruir Inventory desde eventos
7. Command Handler ‚Üí inventory.add_stock() (l√≥gica de negocio)
8. Command Handler ‚Üí Guardar nuevos eventos en EventStore
9. Command Handler ‚Üí Publicar eventos al EventBus
10. Event Handlers ‚Üí Actualizar ReadModel, invalidar cach√©
11. API Layer ‚Üí Retornar 201 Created
```

### Flujo de Consulta (Lectura)

```
1. Cliente ‚Üí HTTP GET /api/v1/inventory/products/{id}/stores/{id}
2. API Layer ‚Üí Validar par√°metros
3. API Layer ‚Üí Crear GetStockQuery
4. Service Layer ‚Üí Invocar GetStockQueryHandler
5. Query Handler ‚Üí Verificar cache primero
6. Query Handler ‚Üí Si fall√≥ cach√©, consultar ReadModel
7. Query Handler ‚Üí Guardar en cach√© por 30s
8. API Layer ‚Üí Retornar 200 OK con datos
```

### Flujo de Evento

```
1. Evento publicado ‚Üí EventBus.publish(StockAdded)
2. EventBus ‚Üí Notificar a todos los subscribers
3. ReadModelUpdater ‚Üí Actualizar proyecci√≥n
4. CacheInvalidator ‚Üí Invalidar entradas relevantes
5. (Futuro) ExternalPublisher ‚Üí Enviar a Kafka
```

## Consideraciones de Escalabilidad

### Escalado Horizontal

**Lado de Escritura**:
```
Load Balancer
     ‚îÇ
     ‚îú‚îÄ‚Üí API Instance 1 ‚îÄ‚Üí Event Store (Sharded by aggregate_id)
     ‚îú‚îÄ‚Üí API Instance 2 ‚îÄ‚Üí Event Store (Sharded by aggregate_id)
     ‚îî‚îÄ‚Üí API Instance 3 ‚îÄ‚Üí Event Store (Sharded by aggregate_id)
```

**Lado de Lectura**:
```
Load Balancer
     ‚îÇ
     ‚îú‚îÄ‚Üí Read API 1 ‚îÄ‚Üí Redis Cache ‚îÄ‚Üí Read Replicas
     ‚îú‚îÄ‚Üí Read API 2 ‚îÄ‚Üí Redis Cache ‚îÄ‚Üí Read Replicas
     ‚îî‚îÄ‚Üí Read API 3 ‚îÄ‚Üí Redis Cache ‚îÄ‚Üí Read Replicas
```

### Estrategias de Cach√©

1. **Cach√© de nivel 1**: En memoria en cada instancia (actual)
2. **Cach√© de nivel 2**: Redis compartido entre instancias (futuro)
3. **Invalidaci√≥n**: Basada en patrones o TTL
4. **Calentamiento**: Prellenado de elementos de alta demanda

### Particionamiento

- **Event Store**: Particionar por `(product_id, store_id)`
- **Read Models**: Desnormalizar y replicar seg√∫n sea necesario
- **Cach√©**: Claves distribuidas en cluster Redis

### L√≠mites de Escalabilidad

| Componente | L√≠mite Actual | Escalado con |
|------------|---------------|--------------|
| Event Store | ~10K eventos/s | Sharding de DB |
| Read Models | ~50K req/s | Redis + Replicas |
| API Instances | ~1K req/s/instancia | Horizontal |
| Event Bus | En memoria | Kafka/RabbitMQ |

## Mejoras Futuras

### Arquitectura

- [ ] Rastreo distribuido (Jaeger/OpenTelemetry)
- [ ] Event Store basado en PostgreSQL
- [ ] Bus de eventos con Kafka
- [ ] Cach√© con Redis
- [ ] API Gateway (Kong/Nginx)
- [ ] Service Mesh (Istio)

### Patrones

- [ ] Saga Pattern para transacciones distribuidas
- [ ] CQRS con Event Sourcing completo
- [ ] Materializaci√≥n de vistas bajo demanda
- [ ] Snapshot de agregados para rendimiento
- [ ] Outbox Pattern para garant√≠as de entrega

### Observabilidad

- [ ] Exportaci√≥n de m√©tricas (Prometheus)
- [ ] Dashboards (Grafana)
- [ ] Alertas (AlertManager)
- [ ] Log aggregation (ELK Stack)

## Referencias

- **Clean Architecture**: Robert C. Martin
- **Domain-Driven Design**: Eric Evans
- **Event Sourcing**: Greg Young
- **Microservices Patterns**: Chris Richardson